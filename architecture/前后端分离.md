#前后端分离

---

差不多一年前，在D2上听了前后端分离的分享，使用`nodejs`当中间层。当时我是反对在团队里做这事的，因为工作量会在短时间大很多。这里的工作量不光指代码量。使用这种方案，除了数据库优化,其他所有后端要做的事，现在我们都要做。简单的增删改查、写业务还好，一些后端的架构，缓存的处理，运维的思维，这个都是要一个个坑去踩的。

现在，这个方面的缺点依然在，但是我也看到这种方案的一些优点。并正在考虑是否在下一个项目中小规模的使用。所以最近做了很多可行性方面的探索。

##1 是否必须加node中间层
当然不是必须的。

还有一种简单使用，又很成熟的方案：模板 + ajax。

1. `SEO`是个问题，不过有解决方案。
2. 首屏`loading`遮罩并不会显著降到用户体验。
3. 简单实用，大部分前端都熟悉的技能。
4. 如果测试api完善，开发的时候前端不需要开任何的server。

加上各种前端框架，如果你主要考虑的是`完成业务`，这种方案个人认为是首选。有个地方要注意。

`跨域问题`。一般api都是有的，但是native app不存在跨域问题，api一般使用二级域名`api.xxx.com`,但是浏览器有跨域问题，`yyy.xxx.com` 访问 `api.xxx.com`的接口，如果是只读的请求，`jsonp`就可以,但是涉及`post`，`delete`的请求，后端要做`cors`的处理。

有个变种：如果觉得首屏上来没内容不能忍受，可以让后端把首屏的数据，以`json`格式写到首屏。因为后端render json的接口一般都有的，这种东西渲染到页面的工作量很小。

###插一句，关于react-native
react-native使用`fetch`来获取数据，写`reactjs`事，如果使用`isomorphic-fetch`，那么以后rn成熟，各端的数据层基本就可以共用了。但是`fetch`并不直接支持jsonp，这样`get`方法后端也要`cors`.

##2 加node中间层到底有哪些可玩的

###极简模型

浏览器 -> node(代理转发，适当包装) -> 后台已有接口（java，golang等）

简单的`api`代理，非常简单，使用`superagent`去请求`api`,稍作处理，返回给前端。代码示例如下

	var apiObj = {
    	get : function(next,queryObj){
    		// ======== before ========
            superagent(getApiUrl('/posts'))
                .query(queryObj)
                .accept('application/json')
                .end((err,res)=>{
               		// ======= after =======	
                   next(err,res.body);
                })
        },
    }
    
    //controller里调用
    router.get('/',function(req,res){
    	var page = req.query['page'] || 1;
    	
    	apiObj(function(err,result){
        	res.json(result)
    	},{page:page})
	})
	
1. 监控api：请求api的地方，有个两个位置，一个`before`请求开始，一个`after`请求结束。要考虑预留这两个位置，，用了做一些拦截的东西。比如最简单的，记录一下`before`和`after`的时间，减一下，就是接口的响应时间。基本的api监控就有了。
2. 统计功能，`before`时能得到用户的请求数据，`after`能得到返回给用户的数据，用户的行为就完整的记录下来了。不过这种最好还是交给处理数据的同事。如果没有数据平台，可以先玩玩。
3. 无跨域问题。
4. 可以把分而治之的思想发挥到极致。后端维护好api，我这边可以为每个项目建一个node中间层。我的一个想法，就是把这些东西弄的很轻，到时有重大需求变更，能重构重构，不能重构直接重写。

##3 node运维
运维方法的经验还比较匮乏。目前的想法是 一部分运维的工作交给云平台，监控也有比较不错的产品。

node的服务做到`异常重启` 和 更新版本时服务`zero downtime`。这个后面踩完坑在说。
